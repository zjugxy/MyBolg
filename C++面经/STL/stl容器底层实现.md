# vector

vector的数据结构主要由三个迭代器(指针)来完成：指向首元素的start，指向尾元素的finish和指向内存末端的end_of_storage。

list 循环双向量表

deque双向队列，由分段连续空间构成
首先对元素的访问需要经过两个层次，第一次找到元素所在的内存块，第二次找到块中的元素。不过这个时间几乎是可以忽略，除非对性能要求极其苛刻。

priority_queue，优先队列。是由以vector作为底层容器，以heap作为处理规则，heap的本质是一个完全二叉树。
建堆，插入数组最后，比较idx/2对应的数，向上传递

set和map。底层都是由红黑树实现的。

内存分配与释放频率和策略才是影响stl各大容器的性能最关键的点”

这点非常重要。不同的操作系统，不同的运行库，他的虚拟内存管理算法，以及运行库的malloc和free的内部实现都是有差异的。如何找出最有效率的使用标准库容器的方式，一定要结合这一点进行大量的测试才能得出。

有一点可以确认的是：各个标准库的实现，已经是在遵循c++标准的基础上，在性能和适用性上可以说做到了极致。因此很多人总想自己造重复的轮子是大可不必。理解好各种容器的实现原理，再结合实际应用的需求，选择合适的容器，以及容器的使用方式，才是上上之策。

# STL内存管理

SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器，直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放。**当分配的空间大小小于128B时，将使用第二级空间配置器，采用了内存池技术，通过空闲链表来管理内存。**

malloc new需要系统调用，转化为内核态。内存池预先分配一个较大的内存块，划分为多个固定大小的内存块，应用程序直接向内存池申请，

# push back emplace back

push back一般先构造函数，再调用移动构造函数或者是拷贝构造函数、
emplace back则只调用构造函数、



